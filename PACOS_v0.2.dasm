; Panacea Creations Operating System (PaCOS) v0.2
; Conforms to DCPU specs version 1.6 (Easily upgraded to 1.7, but held back for emulator support.)
; Copyright © 2012 Panacea creations; All Rights Reserved.

; Contains drivers for the following hardware:
; LEM1802 - Low Energy Monitor (ID 0x7349f615) version 0x1802
; Generic Keyboard             (ID 0x30cf7406) version 0x0001
; Generic Clock                (ID 0x12d0b402) Version 0x0001

; ==== PROGRAM DEVELOPEMENT FOR PaCOS =======================
; PaCOS allows for several special parameters to be stored in the header
; of a program. Headers are optional. To specify that a header is included,
; the first byte of the program should be 0xFFFF. The header format is as follows:

; Data Size         Description
;     1          Amount of additional memory required (after program code)
;                This can be used for getting a larger stack frame ect. By 
;                default, PaCOS will give a program at least 0x0032 bytes
;                for the stack frame. If more is required, it must be specified.

; PaCOS allows for two methods of running programs, both of 
; which allow for relocatable code.
; 1) Using a relocation table. If the first byte (or first byte
;    after the header) of the loaded
;    program is the magic number 0x5254, PaCOS will look for a 
;    relocation table as defined using standards available here:
;    https://github.com/0x10cStandardsCommittee/0x10c-Standards/blob/master/ASM/Draft_Assembly_Relocation_Table.txt
; 2) If the program does not start with the magic number, PaCOS
;    will assume the program has been created using relative jumps
;    and thus the code needs no relocation processing.
;
; System calls can be done using the API table. Usage is
; straight foreward and is explained  below.
;
; Security Notice: Because the DCPU-16 has no memory management,
; all programs are responsible for not modifying memory outside
; of their scope. Because of this, users should be careful of
; what programs are run, as PaCOS can offer no protection from
; malicious code.

SET PC, boot


; ==== API table ===================
; Below are functions that are available to be used in any program.
; Many require an external device and driver to operate. If they are
; called before an appropriate driver is installed, the NO_DRIVER
; handler will be run instead.
; The table starts at memory position 0x0002, and each entry is exactly 
; two bytes long with the driver address going into the second byte.
; So for example, if an external program wished to call the print command,
; the instruction SET PC, 8 should be used (2 + 2*[instuction ID])
:s_API_TABLE    
    

;                                                                  Instruction ID
;void printChar(A char character)                                       [0]
; Print a single character to the console.
:printChar
    SET PC, NO_DRIVER
      
;void newLine(void)                                                     [1]
; Move to next line
:newLine
    SET PC, NO_DRIVER
    
;void shiftView(void)                                                   [2]
; Moves all characters up one line
:shiftView
    SET PC, NO_DRIVER
    
;void print(A string* message)                                          [3]
; Prints a string to the console
:print
    SET PC, NO_DRIVER

;void printLine(A string* message)                                      [4]
; Prints a string to the console followed by a newline.
:printLine
    SET PC, d_printLine

;void clr(void)                                                         [5]
; clears all terminal values.
:clr
    SET PC, NO_DRIVER
    
;A buffer* getBufferAddress(void)
; Returns the address of the cyclic keyboard input buffer               [6]
:getBufferAddress
    SET PC, NO_DRIVER
    
;A addr getPrintColVar(void)
; Returns the address to the PRINT_COL global variable to be read/set.  [7]
:getPrintColVar
    SET PC, d_getPrintColVar
    
;void yield(void)
; Yield to the next process (for optional cooperative multi-tasking)    [8]
:yield
    SET PC, d_yield
    
;A addr getMonitorAddress(void)
; Returns the address to the monitor buffer                             [9]
:getMonitorAddress
    SET PC, NO_DRIVER

;A addr getClockAddress(void)
; Returns the address to the system clock                               [10]    
:getClockAddress
    SET PC, d_getClockAddress

;A byte getClockSpeed(void)
; Returns the system CLOCK_SPEED                                        [11]
:getClockSpeed
    SET PC, d_getClockSpeed
    


; ==== API SUPPORT =====================
; includes API functions that are independant of specific drivers.
    
:s_API_SUPPORT

:d_printLine
    JSR print
    JSR newLine
    SET PC, POP
    
:d_getPrintColVar
    SET A, PRINT_COL
    SET PC, POP
    
:d_yield
    IAQ 1
    SET PUSH, A
    SUB SP, 1
    JSR switchContext
    ADD SP, 1
    RFI
    
:d_getClockAddress
    SET A, CLOCK
    SET PC, POP
    
:d_getClockSpeed
    SET A, [CLOCK_SPEED]
    SET PC, POP
    
    
; ==== BIOS ==========================
; Scans for hardware that is plugged in and installs drivers.

:s_BIOS

:boot
    
    HWN I                        ; Search for a monitor device first
    :.monloop
    SUB I, 1
    IFE I, 0xFFFF
    SET PC, .hwstart
    HWQ I
    
    ; LEM1802 Monitor
    IFE A, 0xF615
    IFE B, 0x7349
    JSR d_7349f615_1802_install
    
    SET PC, .monloop
    
    
    :.hwstart
    HWN I                       ; Handle remaining IO devices
    :.hwloop
    SUB I, 1
    IFE I, 0xFFFF
    SET PC, .hwdone
    HWQ I
    
    
    
    ; Generic Keyboard
    IFE A, 0x7406
    IFE B, 0x30CF
    JSR d_30cf7406_1_install
    
    ; Generic Clock
    IFE A, 0xB402
    IFE B, 0x12D0
    JSR d_12D0B402_1_install
        
    SET PC, .hwloop
    
    :.hwdone
    SET A, mes_boot_complete
    JSR printLine
 
 
; ==== CORE KERNEL ========================
; The core kernel handles loading of programs from disk
; and multitasking context-switching between them.
 
:s_KERNEL
    
    IFE [boot_req_hw], 0xFFFF   ; Check that all manditory hardware was installed.
    SET PC, .done_reqhw
    SET A, mes_lack_hw
    JSR print
    SET PC, crash
    :.done_reqhw
    
    SET A, s_ALLOCATION        ; Reserve OS space
    JSR reserveSectors    
    
    SET A, mes_logo             ; Display PaCOS logo
    JSR printLine
    
    ;SET A, test_program_end
    ;SUB A, test_program         ; Start a test process (letter printing)
    ;SET B, test_program
    ;SET Z, 1
    ;JSR loadProgram
    
    SET A, second_program_end   ; Start a second process (color switching)
    SUB A, second_program
    SET B, second_program
    SET Z, 1            ; yeild 60/1 = 60 times per second.
    JSR loadProgram
    
    SET A, prog_clock_end
    SUB A, prog_clock
    SET B, prog_clock
    SET Z, 5            ; yeild 60/5 = 12 times per second
    JSR loadProgram
    
    IAS s_KERNEL_ISR            ; Enable interrupts (ie allow processes to start running)
    IAQ 0     
    
:crash SET PC, crash

; void switchContext(void)
; Should be called by the installed clock driver to notify the kernel
; that it is time for a context switch.
:switchContext
    SET [CONTEXT_COUNT], 0
    
    IFE [CONTEXT_ID], 0 ;check if first process is starting up...
    SET PC, .first
        
    ;Find next context...
    SET A, [CONTEXT_ID]
    :.loop
    ADD A, 15
    IFE A, process_table_end
    SET A, s_PROCESS_TABLE
    IFC [A], 0x0001
    SET PC, .loop
    
    IFE A, [CONTEXT_ID] ;next context == current context.. just stop here.
    SET PC, POP
    
    SET [.nextContext], A
    SET A, [CONTEXT_ID]
    ADD SP, 2   ; remove return addresses for switchContext and the clock driver ISR
    SET [A+3], POP  ; Saved A value from before interrupt
    SET [A+4], B
    SET [A+5], C
    SET [A+6], X
    SET [A+7], Y
    SET [A+8], Z
    SET [A+9], I
    SET [A+10], J
    SET [A+11], SP
    ADD [A+11], 1    ; Account for the excess PC still sitting on the stack.
    SET [A+12], EX
    SET [A+13], POP ; Saved PC value from before interrupt.    
    SET A, [.nextContext]
    
    
    :.load ; A should be pointing to new context by this point...
    SET [CONTEXT_ID], A
    SET [CONTEXT_LIMIT], [A+14]
    SET B, [A+4]
    SET C, [A+5]
    SET X, [A+6]
    SET Y, [A+7]
    SET Z, [A+8]
    SET I, [A+9]
    SET J, [A+10]
    SET SP, [A+11]
    SET EX, [A+12]
    SET PUSH, [A+13]    ; push wanted SP to stack
    SET PUSH, [A+3]     ; push wanted A  to stack
    RFI                 ; enables interrupts and sets SP and A.    
    
    
    :.first
    IFC [s_PROCESS_TABLE], 0x0001   ;no processes running...
    SET PC, POP
    SET A, s_PROCESS_TABLE
    ADD SP, 4   ; remove RET1, RET2, A, and SP from stack
    SET PC, .load
    
    :.nextContext DAT 0
    
; void loadProgram(A byte filesize, B file* program, Z priority)
:loadProgram   
    SET PUSH, J
    SET PUSH, I
    SET PUSH, X
    SET PUSH, Y    
    SET PUSH, C
    
    SET C, 0x0032 ;Default garunteed space for stack frame.
    
    IFN [B], 0xFFFF
    SET PC, .noHeader
    ADD B, 1
    SET C, [B]  ;read needed extra memory space.
    
    
    :.noHeader
    SET X, A    ;backup arguments.
    SET Y, B
        
    ADD A, C               ; extra for stack frame.
    JSR reserveSectors         ; Load the test_program program.
    SET I, Y    ; src = progam file
    SET J, A    ; dest = sectorStart
    SET A, Y    ; lastByte = file + filesize - 1
    ADD A, X
    SUB A, 1
    JSR relocateProgram
    SET A, J
    JSR newProcess
    
    SET C, POP
    SET Y, POP
    SET X, POP
    SET I, POP
    SET J, POP
    SET PC, POP
    
; void newProcess(A sector* sectorStart, B sector* sectorEnd, Z priority)
:newProcess
    SET PUSH, I
    
    SET I, s_PROCESS_TABLE
    :.loop
    IFC [I], 0x0001
    SET PC, .found
    ADD I, 15    
    
    IFE I, process_table_end
    SET PC, .noroom
    SET PC, .loop
    
    :.found
    BOR [I], 0x0001     ; status
    SET [I+1], A        ; sector_start
    SET [I+2], B        ; sector_end    
    SET [I+13], A       ; PC
    SET [I+14], Z       ; priority
    
    SET PUSH, B
    ADD B, [SECTOR_SIZE]    ;SP starts at sectorEnd + SECTOR_SIZE - 1
    SUB B, 1
    SET [I+11], B       ; SP    
    SET B, POP
    
    SET PC, .done
    
    :.noroom
    ; not sure what will go here.... silently fails for now.
    
    :.done
    SET I, POP
    SET PC, POP
    
;void relocateProgram(I addr src, J addr dest, A addr src_end)
; Copies a program from the src to dest.
; Eventually will apply relocation tables, ect.
:relocateProgram
    SET PUSH, I
    SET PUSH, J    
    SET PUSH, A
    SET PUSH, B
    SET PUSH, C
        
    SET PUSH, J
    SET PUSH, J
    
    :.loop
    STI [J], [I]
    IFG I, A
    SET PC, .doneCopy
    SET PC, .loop
    
    :.doneCopy
    
    SET A, POP
    IFN [A+2], 0x5254
    SET PC, .skip
    JSR .relocate        
    SET A, POP
    ADD A, 1
    SET [A], B
    SET PC, .done
    
    ;; Relocator
    :.relcount
    DAT 0x0000
    :.reloff
    DAT 0x0000
    :.relocate
    SET PUSH, I
    SET B, A
    ADD A, 0x0001
    SET [.reloff], [A]
    SUB [.reloff], 0x0001
    ADD A, 0x0003
    SET [.relcount], [A]
    SET I, 0x0000
    ADD A, 0x0001
    :.relo_loop
    SET C, B
    ADD C, [.reloff]
    ADD C, [A]
    ADD [C], B
    ADD I, 0x0001
    ADD A, 0x0001
    IFG [.relcount], I
    SET PC, .relo_loop
    :.relo_end
    ADD B, [.reloff]
    ADD B, 0x0001
    SET I, POP
    SET PC, POP
    
    :.skip
    SET A, POP
    

    :.done
    SET C, POP
    SET B, POP
    SET A, POP
    SET J, POP
    SET I, POP
    SET PC, POP


; ==== PROCESS TABLE =====================
; Stores information on currently running
; processess and where they can be found in memory.
; Each entry takes the following format:
; [1] status byte
;     --> abcd efgh ijkl mnop
;         p: used (unused/used)
; [1] sector start: First sector reserved by program
; [1] sector end: Last sector reserved by proram
; [11] context: saved copies of registers in order: ABCXYZIJ SP EX PC
; [1] priority: Process is given (priority/freq) seconds each cycle.
;
; There is (currently) support for up to 8 concurrent processes.
; This could easily be increased to around 30 in the future. 
:s_PROCESS_TABLE
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
:process_table_end
    

; === ISR HANDLER ===================
; All interrupts will be received by the ISR below. The ISR simply runs the function
; pointed to by the interrupt message.
:s_KERNEL_ISR
    IAQ 1            
    JSR A        
    RFI    


; ==== ALLOCATION_TABLE =============
; Stores which program allocation sectors are currently in use.
; The RAM is devided into 64 sectors each of 0x0400 bytes in size.
; Each sector has a status bit in the allocation table with the following format:
; abcd efgh ijkl mnop
; p : reserved bit (unused / taken)
:s_ALLOCATION_TABLE
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
:allocation_table_end
    
; (A sector* start, B sector* end) reserveSectors(A byte dataLength)
; Reserves a given amount of space in RAM. If there is not enough space,
; both A and/or B will be set to 0xFFFF.
:reserveSectors
    SET PUSH, I
    SET PUSH, J
    
    SET B, A
    DIV B, [SECTOR_SIZE]
    MOD A, [SECTOR_SIZE]   ; Calculate number of sectors needed
    IFN A, 0
    ADD B, 1
    SET I, B
    
    SET J, I                    ; I-needed sectors, J-sector_count, A-start, B-end
    SET B, s_ALLOCATION_TABLE
    SET A, B
    
    
    :.loop
    IFE B, allocation_table_end
    SET PC, .noroom
    
    IFB [B], 0x0001
    SET PC, .next
    
    SUB J, 1
    IFE J, 0
    SET PC, .doReserve
    
    ADD B, 1    
    SET PC, .loop
    
    
    :.next
    ADD B, 1    
    SET A, B
    SET J, I
    SET PC, .loop
    
    
    :.doReserve  ; A-start, B-end
    SET I, A
    :.reserveLoop
    BOR [I], 0x0001
    ADD I, 1
    IFG I, B
    SET PC, .convert
    SET PC, .reserveLoop
    
    :.convert
    SUB A, s_ALLOCATION_TABLE
    SUB B, s_ALLOCATION_TABLE
    MUL A, [SECTOR_SIZE]
    MUL B, [SECTOR_SIZE]    
    SET PC, .done
    
    :.noroom
    SET A, 0xFFFF
    SET B, 0xFFFF    
    
    :.done
    SET J, POP
    SET I, POP
    SET PC, POP
    
; void freeSector(A sector* sector)
; Frees the given sector so that it can be reused by another program.
:freeSector
    SET PUSH, A    
    
    DIV A, [SECTOR_SIZE]
    ADD A, s_ALLOCATION_TABLE
    AND [A], 0xFFFE
    
    SET A, POP
    SET PC, POP

    
; ==== VARIABLES ===================
; Reserve (and initialize in some cases) global variables
; used by the kernel.

:s_VARIABLES
    :boot_req_hw DAT 0xFFF8 ;required hardware for boot bitmap
                            ; 1 = monitor, 2 = keyboard, 4 = clock
                            
    :mes_boot_complete DAT "Starting Kernal...", 0x000A, 0x0000
    :mes_lack_hw       DAT "Failed to launch PaCOS, missing required hardware.", 0x0000
    ;:mes_logo          DAT "   ___        ___   ___  __", 0x000A
    ;                   DAT "  / _ \\__ _  / __\\ /___\\/ _\\", 0x000A
    ;                   DAT " / /_)/ _` |/ /   //  //\\ \\",  0x000A                ; Escaped logo
    ;                   DAT "/ ___/ (_| / /___/ \\_// _\\ \\", 0x000A
    ;                   DAT "\\/    \\__,_\\____/\\___/  \\__/", 0x0000 
                       
    :mes_logo          DAT "   ___        ___   ___  __", 0x000A
                       DAT "  / _ \__ _  / __\ /___\/ _\", 0x000A
                       DAT " / /_)/ _` |/ /   //  //\ \",  0x000A                   ; Standard logo
                       DAT "/ ___/ (_| / /___/ \_// _\ \", 0x000A
                       DAT "\/    \__,_\____/\___/  \__/", 0x0000    
                       
    :PRINT_COL DAT 0xF000
    :CLOCK_SPEED   DAT 1  ; Freq = (60/CLOCK_SPEED)Hz
    :CLOCK         DAT 0
    :CONTEXT_COUNT DAT 0
    :CONTEXT_LIMIT DAT 1   ; Context will switch at a rate of (Freq/CONTEXT_LIMIT)Hz
    :CONTEXT_ID    DAT 0   ; Currently running context. 0 = none.
    :SECTOR_SIZE   DAT 0x0400   ; Size of each sector to split memory into. Make sure to adjust the allocation accordingly.
    

    
; ==== DRIVERS =====================
; Drivers should be labelled as d_[ID]_[Version].
; Driver global variables should be stored at the beginning of the driver.
; An _install function should exist to be run when the IO device is detected.
; This function should prepare the device for use and replace the needed addresses
; from the kernel's API table.
:s_DRIVERS

:NO_DRIVER
    SET PC, POP

    
; ---- LEM1802 DRIVER --------------
:d_7349f615_1802
    :d_7349f615_1802_CURSOR_LOC DAT 0
    :d_7349f615_1802_mes_monitor_startup DAT "Detecting Hardware...", 0x000A, 0x000A
                         DAT "Device Name      | Driver ver #", 0x000A
                         DAT "LEM1802          | 1802 ", 0x0000
    :d_7349f615_1802_video DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   ; Reserve Video RAM (386 bytes total)
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    :d_7349f615_1802_videoLastRow
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   ; last row (32 bytes total)
                           DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    :d_7349f615_1802_videoLast
                           DAT 0                                                            ; Last character (1 byte)
    :d_7349f615_1802_videoEnd
    
:d_7349f615_1802_install    
    SET PUSH, A
    SET PUSH, B
    
    BOR [boot_req_hw], 0x0001               ; Mark req_hw as having a monitor
    
    SET A, 0
    SET B, d_7349f615_1802_video            ; Map the video RAM
    HWI I
    
    SET [d_7349f615_1802_CURSOR_LOC], d_7349f615_1802_video ; Set the cursor to the first position.
    
    SET A, printChar
    SET [A+1], .printChar
    
    SET A, newLine
    SET [A+1], .newLine
    
    SET A, shiftView
    SET [A+1], .shiftView
    
    SET A, print
    SET [A+1], .print    
    
    SET A, clr
    SET [A+1], .clr
    
    SET A, getMonitorAddress
    SET [A+1], .getMonitorAddress
    
    
    SET A, d_7349f615_1802_mes_monitor_startup
    JSR printLine
    
    SET B, POP
    SET A, POP
    SET PC, POP
    
:.printChar
    SET PUSH, A
    SET PUSH, Z    
    
	IFE A, 0x000A
    SET PC, ._newline__printChar
    
    AND A, 0x00FF
    BOR A, [PRINT_COL]
    SET Z, [d_7349f615_1802_CURSOR_LOC]
    SET [Z], A
    ADD Z, 1
    SET [d_7349f615_1802_CURSOR_LOC], Z
    
    IFG Z, d_7349f615_1802_videoLast ;Passed end of console output
    JSR newLine
    SET PC, ._done__printChar
    
    :._newline__printChar
    JSR newLine    
    
    :._done__printChar    
    SET Z, POP
    SET A, POP    
    SET PC, POP
    
    
:.newLine
    SET PUSH, Z
    SET Z, [d_7349f615_1802_CURSOR_LOC]

    SUB Z, d_7349f615_1802_video
    DIV Z, 32
    ADD Z, 1
    MUL Z, 32
    ADD Z, d_7349f615_1802_video
    IFG Z, d_7349f615_1802_videoLast
    SET PC, ._offscreen__newLine
    SET PC, ._done__newLine
    
    :._offscreen__newLine
    SET Z, d_7349f615_1802_videoLastRow
    JSR shiftView
    
    :._done__newLine
    SET [d_7349f615_1802_CURSOR_LOC], Z
    SET Z, POP
    SET PC, POP
    
    
:.shiftView
	SET PUSH, X
    SET PUSH, Y
    
    SET X, d_7349f615_1802_video
    :._loop__shiftView			; Move all rows upwards (except last)
    SET Y, X
    ADD Y, 0x0020
    SET [X], [Y]
    ADD X, 1
    IFE X, d_7349f615_1802_videoLastRow
    SET PC, ._next__shiftView
    SET PC, ._loop__shiftView
    
    :._next__shiftView			; Clear bottom row
    SET [X], 0x0020
    ADD X, 1
    IFG X, d_7349f615_1802_videoLast
    SET PC, ._end__shiftView
    SET PC, ._next__shiftView
    
 	:._end__shiftView
    SET Y, POP
    SET X, POP
	SET PC, POP
    

:.print
    SET PUSH, A
	SET PUSH, X
    SET PUSH, I
    SET I, A
    
    ;check for color bit
    SET X, [PRINT_COL]
    IFN [I], 0xFFFF
    SET PC, ._loop__print
    ADD I, 1
    SET [PRINT_COL], [I]
    ADD I, 1
    
    :._loop__print
    SET A, [I]
    IFE A, 0x0000
    SET PC, ._done__print
    JSR printChar
    ADD I, 1
    SET PC, ._loop__print

    :._done__print
    SET [PRINT_COL], X
    SET I, POP
    SET X, POP    
    SET A, POP
    SET PC, POP
    
:.clr
    SET PUSH, Z
    SET Z, [d_7349f615_1802_CURSOR_LOC]
    
    SET Z, d_7349f615_1802_video
    :._loop__clr
    SET [Z], 0x0000
    ADD Z, 1
    IFN Z, d_7349f615_1802_videoEnd
    SET PC, ._loop__clr
    SET Z, d_7349f615_1802_video
    
    SET [d_7349f615_1802_CURSOR_LOC], Z
    SET Z, POP
    SET PC, POP
    
:.getMonitorAddress
    SET A, d_7349f615_1802_video
    SET PC, POP
    
    
; ---- Generic Keyboard Driver ------------------
:d_30cf7406_1
    :mes_install__30cf7406_1 DAT "Generic Keyboard | 1", 0x0000
    :d_30cf7406_1_IO_ADD DAT 0x0000
    :d_30cf7406_1_buf DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    :d_30cf7406_1_bufPoint DAT 0
    
:d_30cf7406_1_install
    SET PUSH, A

    SET [d_30cf7406_1_bufPoint], d_30cf7406_1_buf
    
    BOR [boot_req_hw], 0x0002           ; Mark req_hw having installed a keyboard
    SET [d_30cf7406_1_IO_ADD], I        ; Save the IO address for this device.
    
    SET A, getBufferAddress
    SET [A+1], d_30cf7406_1_getBufferAddress
    
    SET B, d_30cf7406_1_ISR             ; Activate interrupts
    SET A, 3
    HWI I
    
    SET A, mes_install__30cf7406_1
    JSR printLine
    
    SET A, POP
    SET PC, POP
    
:d_30cf7406_1_ISR
    SET PUSH, C
    
    SET A, 1
    HWI [d_30cf7406_1_IO_ADD]
    IFE C, 0    ; buffer is empty (ie intr caused by key pressed/released events)
    SET PC, .skip
    
    SET A, [d_30cf7406_1_bufPoint]
    SET [A], C
    ADD A, 1
    IFE A, d_30cf7406_1_bufPoint
    SET A, d_30cf7406_1_buf
    SET [d_30cf7406_1_bufPoint], A
    
    :.skip
    SET C, POP
    SET PC, POP
    
:d_30cf7406_1_getBufferAddress
    SET A, d_30cf7406_1_buf
    SET PC, POP
    
    
; ---- Generic Clock Driver --------------------
:d_12D0B402_1
    :mes_install__12D0B402_1 DAT "Generic Clock    | 1", 0x0000
    :d_12D0B402_1_IO_ADD DAT 0x0000
    
:d_12D0B402_1_install
    SET PUSH, A
    
    BOR [boot_req_hw], 0x0004               ;Mark req_hw as having installed a clock.
    SET [d_12D0B402_1_IO_ADD], I            ; Save the IO address for this device.
    
    SET A, 0
    SET B, [CLOCK_SPEED]                    ; Set up clock speed
    HWI I
    
    SET A, 2
    SET B, d_12D0B402_1_ISR                 ; Set up interrupts
    HWI I
    
    SET A, mes_install__12D0B402_1
    JSR printLine
    
    SET A, POP
    SET PC, POP
    
:d_12D0B402_1_ISR
    ADD [CLOCK], 1
    ADD [CONTEXT_COUNT], 1
    IFE [CONTEXT_COUNT], [CONTEXT_LIMIT]
    JSR switchContext
    SET PC, POP
    
    
    
; ==== ALLOCATION ==============================
; The remainder of memory space is used to load 
; and run programs from the hard disks. In order
; for a program to be run, it must abide by
; the specifications found at the top of this file
:s_ALLOCATION


:test_program
        
    SET A, 0x41
    JSR yield
    ADD A, 1
    IFE A, 0x51
    SET A, 0x41
    JSR printChar
    SUB PC, 10
    
:test_program_end

:second_program
        
    DAT 0x7f81, 0x0006 ; SET PC, start
    DAT 0x5254, 0x0001, 0x0001, 0x0009 ; Relocation Table
;   :start
    DAT 0xc420  ; JSR 16 (getPrintColVar)
;   :loop
    DAT 0xcc20  ; JSR 18 (yield)
    DAT 0x7d02, 0x1000 ; ADD [A], 0x1000
    DAT 0x8512  ; IFE [A], 0x0000
    DAT 0x7d02, 0x1000 ; ADD [A], 0x1000
    DAT 0x7f81, 0x0007 ; SET PC, loop

:second_program_end

:prog_clock

    ; A - working reg
    ; B - seconds counter
    ; C - print color address
    ; X - monitor address
    ; Y - Clock address
    ; Z - clock frequency
    
    SET B, 0xFFFF
    JSR getPrintColVar
    SET C, A
    JSR getMonitorAddress
    SET X, A
    JSR getClockAddress
    SET Y, A
    JSR getClockSpeed
    SET Z, 60
    DIV Z, A            ; Set Z to clock freq.
    
    SET A, [Y]
    
    ADD B, 1        ;increment seconds count
    IFE B, 10
      SET B, 0
    ADD A, Z        ;calculate next target clock
    SET [X], B      ;put seconds count to monitor    
    BOR [X], [C]    ;apply color        
    ADD [X], 0x30   ;convert to ascii
    SET PUSH, A
    SET A, [X]
    JSR printChar
    SET A, POP
    IFG [Y], A  
      SUB PC, 15
    SUB PC, 3
    

:prog_clock_end